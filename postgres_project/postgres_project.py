# -*- coding: utf-8 -*-
"""Postgres_project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VqmgM0y9Eu2QLJ7eTIMyjUxgGdZNKiHi

# Создание БД и запросы Postgresql в ipynb

Целью данного проекта является знакомство с функционалом библиотеки Sqlalchemy с последующим решением практических задач для e-commerce, telecom и веб-сервиса.

## План работы

1. [Установка сервера Postgresql, создание пользователя и БД](#scrollTo=QINMj2TmJo_J&line=1&uniqifier=1)
2. [Анализ данных о транзакциях покупателей в e-commerce](#scrollTo=iCxsiY1A-Q8L&line=1&uniqifier=1)
3. [Анализ долей покупок/продаж](#scrollTo=5jKHKr9BF2N1&line=1&uniqifier=1)
4. [Сбор расходов в роуминге и домашней сети абонентов](#scrollTo=bYm79PUQw_xb&line=1&uniqifier=1)
5. [Отбор клиентов, получивших кредит](#scrollTo=TbpYDtnpdo98&line=1&uniqifier=1)
6. [Вывод](#scrollTo=YOamYwAo_oKR&line=1&uniqifier=1)

## Установка сервера Postgresql, создание пользователя и БД
"""

# Установка сервера postgresql
!sudo apt-get -y -qq update
!sudo apt-get -y -qq install postgresql
!sudo service postgresql start

# Создание 'username' - 'password'
!sudo -u postgres psql -U postgres -c "ALTER USER postgres PASSWORD 'postgres';"

# Создание базы данных 'db'
!sudo -u postgres psql -U postgres -c 'DROP DATABASE IF EXISTS db;'
!sudo -u postgres psql -U postgres -c 'CREATE DATABASE db;'

# импорт библиотек
import pandas as pd
import numpy as np
import psycopg2
import sqlalchemy

# подключение к БД и серверу postgres
conn = sqlalchemy.create_engine('postgresql://postgres:postgres@localhost/db')

"""## Задача 1. Группировка и консолидация данных о транзакциях продавцов и покупателей в e-commerce

В таблице total_sales содержится информация о сделках.

Требуется написать SQL запрос, который к каждой транзакции добавит:
- Дату первой сделки покупателя.
- Дату предыдущей сделки покупателя.
- Покажет общее количество товаров, купленных покупателем. Присвоить всем сделкам покупателя / продавца порядковый номер.
"""

# создание датафрейма pandas
rows = {
    'sales_id' : [85754, 40494, 25651, 34489, 83056, 36044, 96498],
    'date' : ['05.04.2022', '12.04.2022', '11.06.2022', '18.06.2022', '06.07.2022', '07.07.2022', '19.07.2022'],
    'buyer_id' : [3, 1, 4, 1, 2, 2, 4],
    'seller_id' : ['a', 'm', 'f', 'f', 'm', 'g', 'e'],
    'qty' : [100, 10, 40, 30, 70, 10, 70],
    'qty_shipped' : [100, 10, np.nan, np.nan, np.nan, 10, 70]
}
total_sales = pd.DataFrame(rows)

# создание таблицы 'total_sales' в 'bd'
total_sales.to_sql(
    'total_sales',
    conn,
    if_exists='replace',
    index=False
)

# SQL-запрос для решения задачи 1
query = ("""
          SELECT *,
          FIRST_VALUE(date) OVER (PARTITION BY buyer_id ORDER BY date ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) first_deal_at,
          FIRST_VALUE(date) OVER (PARTITION BY buyer_id ORDER BY date ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) previous_deal_at,
          SUM(qty) OVER (PARTITION BY buyer_id) total_qty,
          DENSE_RANK() OVER (PARTITION BY buyer_id ORDER BY sales_id) purchase_number,
          DENSE_RANK() OVER (PARTITION BY seller_id ORDER BY sales_id) sale_number
          FROM total_sales
          ORDER BY buyer_id
          """)
pd.read_sql(query, conn)

"""##  Задача 2. Анализ долей покупок/продаж

1. Составьте запросы к базе, отвечающие на вопросы:
- Для каждого покупателя найдите магазин, в котором он совершил наибольшее количество покупок.
- Найдите всех покупателей, которые в каждом полном месяце этого года совершали не менее 3 покупок.
2. Напишите запрос, формирующий представленный отчет.
"""

# импорт модулей sqlalchemy
from sqlalchemy import MetaData, Table, Column, Integer, String, DateTime, ForeignKey

# создание датафреймов pandas
# датафрейм 'stores'
stores_rows = {
    'store_id' : [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
    'store_nm' : ['store_1', 'store_2', 'store_3', 'store_4', 'store_5', 'store_6', 'store_7', 'store_8', 'store_9', 'store_10']
}
stores = pd.DataFrame(stores_rows)

# датафрейм 'customers'
customers_rows = {
    'customer_id' : [101, 102, 103, 104, 105, 106, 107, 108, 109, 110],
    'customer_nm' : ['customer_1', 'customer_2', 'customer_3', 'customer_4', 'customer_5', 'customer_6', 'customer_7', 'customer_8', 'customer_9', 'customer_10']
}
customers = pd.DataFrame(customers_rows)

# датафрейм 'sales'
sales_rows = {
    'sale_id' : [1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026],
    'store_id' : [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 2, 3, 4, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6],
    'customer_id' : [101, 102, 101, 105, 106, 103, 104, 110, 101, 105, 106, 107, 108, 109, 110, 102, 104, 108, 107, 110, 101, 102, 101, 105, 106, 103],
    'dt' : ['2023-01-24', '2023-02-01', '2023-02-07', '2023-02-15', '2023-02-20', '2023-02-23', '2023-02-28', '2023-03-01', '2023-03-05', '2023-03-06', '2023-02-07', '2023-02-20', '2023-02-23', '2023-02-28', '2023-03-05', '2023-03-06', '2023-02-07', '2023-02-01', '2023-02-07', '2023-02-15', '2023-03-05', '2023-03-06', '2023-02-07', '2023-02-01', '2023-02-07', '2023-02-15'],
    'amt' : [100, 500, 200, 400, 800, 500, 300, 200, 100, 600, 100, 500, 200, 400, 800, 500, 300, 200, 100, 600, 100, 500, 200, 400, 800, 500]
}
sales = pd.DataFrame(sales_rows)

# создание таблиц 'stores', 'customers', 'customers' в БД
stores.to_sql('stores', conn, if_exists='replace',index=False)
customers.to_sql('customers', conn, if_exists='replace',index=False)
sales.to_sql('sales', conn, if_exists='replace',index=False)

# создание связей между таблицами
metadata = MetaData()

stores = Table('stores', metadata,
    Column('store_id', Integer(), primary_key=True),
    Column('store_nm', String(200), nullable=False)   
)

customers = Table('customers', metadata,
    Column('customer_id', Integer(), primary_key=True),
    Column('customer_nm', String(200), nullable=False)   
)

sales = Table('sales', metadata,
    Column('sale_id', Integer(), primary_key=True),
    Column('store_id', ForeignKey('stores.store_id')),
    Column('customer_id', ForeignKey('customers.customer_id')),
    Column('dt', DateTime(), nullable=False),
    Column('amt', Integer(), nullable=False)
)

# SQL-запрос для решения задачи 2.1.a
query = ("""
          WITH count AS
          (SELECT DISTINCT customer_id,
                  store_id,
                  COUNT(sale_id) OVER (PARTITION BY customer_id, store_id)
          FROM sales),
          max_count AS
          (SELECT *,
                 MAX(count) OVER (PARTITION BY customer_id)
           FROM count)
           SELECT m.customer_id,
                  c.customer_nm,
                  m.store_id,
                  s.store_nm
           FROM max_count m
           LEFT JOIN customers c using(customer_id)
           LEFT JOIN stores s using(store_id)
           WHERE count = max
          """)
pd.read_sql(query, conn)

# SQL-запрос для решения задачи 2.1.b
query = ("""
          WITH count AS
          (SELECT DISTINCT customer_id,
                  DATE_TRUNC('month', dt::date) mnth,
                  DATE_PART('month', now()) - DATE_PART('month', dt::date) date_diff,
                  COUNT(sale_id) OVER (PARTITION BY customer_id, DATE_TRUNC('month', dt::date))
           FROM sales)
          SELECT cnt.customer_id,
                 c.customer_nm
          FROM count cnt
          LEFT JOIN customers c using(customer_id)
          WHERE count >= 3
          AND date_diff >= 1
          """)
pd.read_sql(query, conn)

# SQL-запрос для решения задачи 2.2
query = ("""
          WITH s_amt AS
          (SELECT DISTINCT (DATE_TRUNC('month', s.dt::date) + INTERVAL '1 month - 1 day')::date month_end_dt,
                  SUM(s.amt) OVER (PARTITION BY DATE_TRUNC('month', s.dt::date)) company_sales_amt,
                  st.store_nm,
                  SUM(s.amt) OVER (PARTITION BY store_nm, DATE_TRUNC('month', s.dt::date)) store_sales_amt
           FROM sales s
           LEFT JOIN stores st using(store_id))
          SELECT *,
                 ROUND(store_sales_amt / company_sales_amt, 2) store_sales_share
                 FROM s_amt
                 ORDER BY month_end_dt
          """)
pd.read_sql(query, conn)

"""## Задача 3. Сбор расходов в роуминге и домашней сети абонентов

### Запрос 1

В таблице calls хранятся данные всех звонков абонентов за отчетный месяц. 

В поле roaming указан факт нахождения абонента в роуминге во время звонка:

1 - абонент был в роуминге;

0 - абонент не был в роуминге.

Напишите SQL запрос, определяющий уникальные id абонентов, которые хоть раз звонили в роуминге за отчетный месяц.
"""

# создание датафрейма
calls_rows = {
    'id_abon' : [1, 2, 3, 1, 2, 3, 1, 1, 1, 1],
    'date' : ['05.04.2022', '12.04.2022', '11.06.2022', '18.06.2022', '06.07.2022', '07.07.2022', '09.07.2022', '12.10.2022', '13.10.2022', '14.10.2022'],
    'time' : ['13:01', '13:30', '13:35', '14:05', '9:07', '00:12', '6:25', '9:07', '00:12', '6:25'],
    'roaming' : [1, 0, 1, 1, 1, 0, 0, 1, 1, 1]
}
calls = pd.DataFrame(calls_rows)

# создание таблицы 'calls' в БД
calls.to_sql(
    'calls',
    conn,
    if_exists='replace',
    index=False
)

# SQL-запрос 1
query = ("""
          SELECT id_abon,
          DATE_TRUNC('month', to_date(date, 'DD.MM.YYYY'))::date mnth
          FROM calls
          WHERE roaming = 1
          """)
pd.read_sql(query, conn)

"""###  Запрос 2

В таблице abnt хранятся уникальные id всех абонентов, совершавших звонки за отчетный месяц. В таблице roam хранятся уникальные id абонентов, которые были в роуминге за отчетный месяц.

Напишите SQL запрос, результатом которого будут все id абонентов, которые не были в роуминге в текущем месяце.
"""

# создание датафреймов
# датафрейм 'abnt'
abnt_rows = {
    'id_abon' : [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
    'date' : ['30.04.2022', '30.04.2022', '30.06.2022', '30.06.2022', '31.07.2022', '31.07.2022', '31.07.2022', '31.08.2022', '31.08.2022', '30.11.2022'],
    'clc' : [60, 50, 30, 20, 10, 100, 50, 10, 30, 40]
}

abnt = pd.DataFrame(abnt_rows)

# датафрейм 'roam'
roam_rows = {
    'id_abon' : [1, 2, 3],
    'date' : ['30.04.2022', '30.06.2022', '31.07.2022'],
    'clc' : [10, 10, 10]
}
roam = pd.DataFrame(roam_rows)

# создание таблиц 'abnt', 'roam' в БД
abnt.to_sql('abnt', conn, if_exists='replace',index=False)
roam.to_sql('roam', conn, if_exists='replace',index=False)

# создание связей между таблицами
metadata = MetaData()

abnt = Table('abnt', metadata,
    Column('id_abon', Integer(), primary_key=True),
    Column('date', DateTime(), nullable=False),
    Column('clc', Integer(), nullable=False)
)

roam = Table('roam', metadata,
    Column('id_abon', ForeignKey('abnt.id_abon'), primary_key=True),
    Column('date', DateTime(), nullable=False),
    Column('clc', Integer(), nullable=False)
)

# SQL-запрос 2
query = ("""
          SELECT DISTINCT id_abon
          FROM abnt
          WHERE id_abon != ALL
            (SELECT a.id_abon
            FROM abnt a
            JOIN roam r using(id_abon)
            WHERE DATE_TRUNC('month', to_date(r.date, 'DD.MM.YYYY')) = DATE_TRUNC('month', now()))
          """)
pd.read_sql(query, conn)

"""### Запрос 3

В таблицах abnt и roam также хранятся данные о тратах абонентов. В таблице abnt есть все начисления абонентов, в таблице roam начисления в роуминге.

Напишите SQL запрос, который выведет всех абонентов с начислениями в домашней сети больше 0.
Начисления в домашней сети= все начисления (abnt.clc) - начисления в роуминге (roam.clc).
"""

# SQL-запрос 3
query = ("""
          WITH clc_groped AS
            (SELECT DISTINCT id_abon,
                    SUM(a.clc) OVER (PARTITION BY id_abon) all_clc,
                    coalesce(SUM(r.clc) OVER (PARTITION BY id_abon), 0) roam_clc
              FROM abnt a
              LEFT JOIN roam r using(id_abon))
          SELECT id_abon
          FROM clc_groped
          WHERE all_clc - roam_clc > 0
          """)
pd.read_sql(query, conn)

"""### Запрос 4

Используя данные таблицы calls, выведите id всех абонентов, у которых было
больше 5 звонков в роуминге.
"""

# SQL-запрос 4
query = ("""
          WITH r_calls AS
              (SELECT id_abon,
                      SUM(roaming) OVER (PARTITION BY id_abon)
               FROM calls)
          SELECT id_abon
          FROM r_calls
          WHERE sum > 5
          """)
pd.read_sql(query, conn)

"""### Запрос 5

Используя данные таблицы calls, выведите периоды нахождения абонентов в
роуминге. Время пребывания в роуминге определяется непрерывной последовательностью звонков в роуминге.
"""

query = ("""
          WITH start_end AS
          (SELECT *,
                 CASE
                      WHEN roaming = 1
                      AND coalesce(LAG(roaming) OVER (PARTITION BY id_abon ORDER BY to_date(date, 'DD.MM.YYYY'), time), 0) = 0
                          THEN date
                      ELSE 0::text
                 END start_roam,
                 CASE
                      WHEN roaming = 1
                      AND coalesce(LEAD(roaming) OVER (PARTITION BY id_abon ORDER BY to_date(date, 'DD.MM.YYYY'), time), 0) = 0
                          THEN date
                      ELSE 0::text
                 END end_roam
          FROM calls)
          SELECT DISTINCT id_abon,
                 CASE
                      WHEN end_roam = '0'
                          THEN start_roam || ' - ' || LAST_VALUE(end_roam) OVER (PARTITION BY id_abon ORDER BY to_date(date, 'DD.MM.YYYY'), time ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING)
                      WHEN start_roam = '0'
                          THEN FIRST_VALUE(start_roam) OVER (PARTITION BY id_abon ORDER BY to_date(date, 'DD.MM.YYYY'), time ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) || ' - ' || end_roam
                      ELSE start_roam || ' - ' || end_roam
                 END start_end_roam
          FROM start_end
          WHERE start_roam != '0'
          OR end_roam != '0'
          """)
pd.read_sql(query, conn)

"""## Задача 4. Отбор клиентов, получивших кредит

У вас есть две таблицы:
- t1 - данные по заявкам на Подбор кредита с сайта Сравни.ру;
- t2 - выгрузка банка о решениях по выдаче кредита.

Напишите SQL-запрос, содержащий всех пользователей, получивших кредит.
"""

# создание датафреймов
# датафрейм 't1'
t1_rows = {
    'id' : [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
    'surname' : ['Петров', 'Иванов', 'Васечкин', 'Филиппов', 'Овсиенко', 'Милов', 'Горбунов', 'Кузнецов', 'Курочкин', 'Климов'],
    'birthday' : ['30.04.1987', '30.04.1990', '30.06.1878', '30.06.1996', '31.07.1993', '31.07.1985', '31.07.1987', '31.08.1991', '31.08.1980', '30.11.1967'],
    'amount' : [600000, 500000, 300000, 200000, 100000, 1000000, 50000, 10000000, 3000000, 400000],
    'salary' : [120000, 50000, 120000, 100000, 50000, 100000, 30000, 200000, 150000, 100000]
}

t1 = pd.DataFrame(t1_rows)

# датафрейм 't2'
t2_rows = {
    'id' : [1, 3, 5, 7, 9, 10],
    'status' : ['выдан', 'отказ', 'отказ', 'выдан', 'отказ', 'выдан']
}
t2 = pd.DataFrame(t2_rows)

# создание таблиц 't1', 't2' в БД
t1.to_sql('t1', conn, if_exists='replace',index=False)
t2.to_sql('t2', conn, if_exists='replace',index=False)

# создание связей между таблицами
metadata = MetaData()

t1 = Table('t1', metadata,
    Column('id', Integer(), primary_key=True),
    Column('surname', String(200), nullable=False),
    Column('birthday', DateTime(), nullable=False),
    Column('amount', Integer(), nullable=False),
    Column('salary', Integer(), nullable=False)
)

t2 = Table('t2', metadata,
    Column('id', ForeignKey('t1.id'), primary_key=True),
    Column('status', String(200), nullable=False)
)

# SQL-запрос 2
query = ("""
          SELECT id,
                 surname
          FROM t1
          JOIN t2 using(id)
          WHERE status LIKE 'выдан'
          """)
pd.read_sql(query, conn)

"""## Вывод

В этом проекте я протестировала использование SQL-запросов непосредственно в тетради Jupyter notebook. Я установила сервер в рабочей среде Google Colab, создала таблицы и настроила связи внутри БД. Могу отметить, что возможность писать запросы в самой тетради может ускорить работу и фиксировать промежуточные результаты, оперативно подгружая данные, необходимые в исследовании.
"""